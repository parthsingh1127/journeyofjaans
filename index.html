<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Our Journey ‚ù§Ô∏è</title>
<style>
  :root{
    --accent:#ff4d6d;
    --fg:#fff;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter, Poppins, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;background:#000;color:var(--fg);overflow:hidden}

  /* ---------- Background slideshow (covers whole viewport) ---------- */
  .bg {
    position:fixed; inset:0; z-index:-2; background:#000;
    overflow:hidden;
  }
  .bg .slide {
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:cover;
    opacity:0;
    transition:opacity 1000ms ease;
    will-change: opacity, transform;
    filter: grayscale(20%) brightness(60%);
    transform: scale(1.02);
    background-size:cover;
  }
  .bg .slide.active { opacity:1; filter: grayscale(10%) brightness(55%); transform: none; }

  /* subtle center-light vignette via overlay so faces stay visible */
  .bg-overlay {
    position:fixed; inset:0; z-index:-1;
    pointer-events:none;
    background: radial-gradient(ellipse at center, rgba(0,0,0,0.06) 0%, rgba(0,0,0,0.35) 65%);
  }

  /* ---------- Popup intro ---------- */
  .overlay {
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background: rgba(0,0,0,0.6); z-index:20;
  }
  .popup {
    background:#fff; color:#222; padding:26px; border-radius:14px; text-align:center;
    box-shadow: 0 18px 60px rgba(0,0,0,0.35);
    max-width:420px; width:92%;
  }
  .popup h2{ color:var(--accent); margin:0 0 8px; font-size:20px; }
  .popup p{ margin:0 0 12px; }
  .heart-btn{
    font-size:46px; background:none; border:0; color:var(--accent); cursor:pointer;
    animation: beat 1000ms infinite; user-select:none;
  }
  @keyframes beat{ 0%,100%{transform:scale(1)} 50%{transform:scale(1.2)} }
  .vanish { animation: vanishAnim 620ms forwards ease; }
  @keyframes vanishAnim { from{opacity:1;transform:scale(1)} to{opacity:0;transform:scale(2)} }

  /* ---------- App container / views ---------- */
  .app {
    position:relative; z-index:10; width:100%; max-width:980px; margin:40px auto; padding:20px;
    pointer-events:none; opacity:0; transform:translateY(8px); transition:opacity .36s ease, transform .36s ease;
  }
  .app.active { pointer-events:auto; opacity:1; transform:none; }

  .card {
    background: rgba(0,0,0,0.36); backdrop-filter: blur(6px);
    padding:18px; border-radius:12px; color:var(--fg);
  }

  /* Timer boxes */
  .timer {
    display:flex; gap:12px; flex-wrap:wrap; justify-content:center; margin:14px 0;
  }
  .box {
    min-width:86px; padding:12px 14px; border-radius:10px;
    background: rgba(255,255,255,0.08); text-align:center;
  }
  .val { font-size:18px; font-weight:700; }
  .label { font-size:11px; color: #ffe8ee; margin-top:6px; }

  /* Controls / links */
  .controls { display:flex; gap:10px; justify-content:center; margin-top:12px; flex-wrap:wrap; }
  .btn {
    pointer-events: auto;
    background:var(--accent); color:#fff; border:0; padding:10px 16px; border-radius:999px; cursor:pointer;
    font-weight:700;
  }
  .muted { background:#fff; color:var(--accent); }

  /* Message view */
  .message-view { display:none; }
  .message-view.show { display:block; }

  /* small screens */
  @media (max-width:640px){
    .val{ font-size:16px }
    .popup h2{ font-size:18px }
    .card{ padding:14px }
  }
</style>
</head>
<body>

  <!-- background container - slides are added by JS after preload -->
  <div class="bg" id="bg"></div>
  <div class="bg-overlay"></div>

  <!-- intro popup -->
  <div class="overlay" id="overlay">
    <div class="popup">
      <h2>Hi baby üíï</h2>
      <p>I hope you liked your surprise.<br>I love you so so much</p>
      <button class="heart-btn" id="heart">‚ù§Ô∏è</button>
    </div>
  </div>

  <!-- single-page app: timerView + messageView -->
  <main class="app" id="app">
    <!-- TIMER VIEW -->
    <section id="timerView" class="card view">
      <h2 style="color:var(--accent);margin:6px 0 10px">Our Journey Together</h2>

      <div class="timer" id="timerBoxes" aria-live="polite"></div>

      <div class="controls">
        <button id="goMessage" class="btn">Click here for another surprise</button>
        <button id="playPause" class="btn muted">‚èØ Play</button>
      </div>
    </section>

    <!-- MESSAGE VIEW (hidden until shown) -->
    <section id="messageView" class="card view message-view" aria-hidden="true" style="margin-top:16px;">
      <h2 style="color:var(--accent);margin:6px 0 10px">My Dearest Ishu ‚ù§Ô∏è</h2>
      <div style="font-size:16px;line-height:1.6; max-width:760px; margin:0 auto;">
        Every passing moment with you feels magical, meri jaan.<br>
        I fall deeper in love every single day.<br><br>
        I love you so much Ishu ‚ù§Ô∏è You are everything ‚ù§Ô∏è
      </div>

      <div class="controls" style="margin-top:18px;">
        <button id="backTimer" class="btn muted">‚¨Ö Back to Timer</button>
        <button id="playPause2" class="btn muted">‚èØ Play</button>
      </div>
    </section>
  </main>

  <!-- two audio elements for seamless crossfade when switching songs -->
  <audio id="audioA" src="Sahiba(KoshalWorld.Com).mp3" preload="auto" crossorigin="anonymous"></audio>
  <audio id="audioB" src="yellow.mp3" preload="auto" crossorigin="anonymous"></audio>

<script>
/* ========= CONFIG ========= */
const imageUrls = [
  'us.jpg','us3.jpg','us5.jpg','us6.jpg','us7.jpg','us8.jpg','us9.jpg','us10.jpg'
];
const startDate = new Date(2024,0,6,0,0,0); // local device timezone
const SLIDE_INTERVAL = 4500;
const CROSSFADE_MS = 800;

/* ========= ELEMENTS ========= */
const overlay = document.getElementById('overlay');
const heart = document.getElementById('heart');
const app = document.getElementById('app');
const timerBoxes = document.getElementById('timerBoxes');
const goMessage = document.getElementById('goMessage');
const messageView = document.getElementById('messageView');
const timerView = document.getElementById('timerView');
const backTimer = document.getElementById('backTimer');
const playPause = document.getElementById('playPause');
const playPause2 = document.getElementById('playPause2');

const bgContainer = document.getElementById('bg');
let slides = [];     // DOM nodes for slides (only for successfully loaded images)
let slideIndex = 0;
let slideTimer;

/* audio */
const audioA = document.getElementById('audioA'); // Sahiba (timer)
const audioB = document.getElementById('audioB'); // yellow (message)
let activeTrack = 'A'; // 'A' or 'B'
let fadeInterval = null;

/* state persistence */
const STORAGE = {
  musicPlaying: 'journey_musicPlaying',
  musicATime: 'journey_musicA_time',
  musicBTime: 'journey_musicB_time',
  unlocked: 'journey_unlocked'
};

/* ========= PRELOAD IMAGES, SKIP MISSING ========= */
function preloadImages(urls, cb) {
  const loaded = [];
  let remaining = urls.length;
  urls.forEach((url) => {
    const img = new Image();
    img.onload = () => {
      loaded.push(url);
      remaining--;
      checkDone();
    };
    img.onerror = () => {
      console.warn('Image failed to load, skipping:', url);
      remaining--;
      checkDone();
    };
    // start loading
    img.src = url;
  });
  function checkDone() {
    if (remaining <= 0) cb(loaded);
  }
}

/* ========= BUILD SLIDES (only from successfully loaded images) ========= */
function buildSlides(loadedUrls) {
  // clear existing
  bgContainer.innerHTML = '';
  slides = [];

  if(loadedUrls.length === 0){
    // fallback: plain gradient background
    bgContainer.style.background = 'linear-gradient(135deg,#ff9a9e,#fad0c4)';
    return;
  }

  loadedUrls.forEach((url, i) => {
    const img = document.createElement('img');
    img.className = 'slide';
    img.src = url;
    if(i === 0) img.classList.add('active');
    bgContainer.appendChild(img);
    slides.push(img);
  });
}

/* ========= START SLIDESHOW ========= */
function startSlides() {
  if(slideTimer) clearInterval(slideTimer);
  if(slides.length <= 1) return;
  slideIndex = 0;
  slideTimer = setInterval(() => {
    slides[slideIndex].classList.remove('active');
    slideIndex = (slideIndex + 1) % slides.length;
    slides[slideIndex].classList.add('active');
  }, SLIDE_INTERVAL);
}

/* ========= TIMER (accurate y/m/d/h/m/s) ========= */
function getDateDiffComponents(s,e){
  const start = new Date(s.getTime()), end = new Date(e.getTime());
  let years = end.getFullYear() - start.getFullYear();
  let months = end.getMonth() - start.getMonth();
  let days = end.getDate() - start.getDate();
  let hours = end.getHours() - start.getHours();
  let minutes = end.getMinutes() - start.getMinutes();
  let seconds = end.getSeconds() - start.getSeconds();

  if (seconds < 0) { seconds += 60; minutes -= 1; }
  if (minutes < 0) { minutes += 60; hours -= 1; }
  if (hours < 0) { hours += 24; days -= 1; }
  if (days < 0) {
    const prevMonthDays = new Date(end.getFullYear(), end.getMonth(), 0).getDate();
    days += prevMonthDays;
    months -= 1;
  }
  if (months < 0) { months += 12; years -= 1; }
  return { years, months, days, hours, minutes, seconds };
}
let timerInterval = null;
function startTimer() {
  if(timerInterval) clearInterval(timerInterval);
  function tick(){
    const diff = getDateDiffComponents(startDate, new Date());
    timerBoxes.innerHTML = `
      <div class="box"><div class="val">${diff.years}</div><div class="label">Years</div></div>
      <div class="box"><div class="val">${diff.months}</div><div class="label">Months</div></div>
      <div class="box"><div class="val">${diff.days}</div><div class="label">Days</div></div>
      <div class="box"><div class="val">${String(diff.hours).padStart(2,'0')}</div><div class="label">Hours</div></div>
      <div class="box"><div class="val">${String(diff.minutes).padStart(2,'0')}</div><div class="label">Minutes</div></div>
      <div class="box"><div class="val">${String(diff.seconds).padStart(2,'0')}</div><div class="label">Seconds</div></div>
    `;
  }
  tick();
  timerInterval = setInterval(tick,1000);
}

/* ========= AUDIO HELPERS (crossfade) ========= */
function setVolumes(aVol, bVol){
  audioA.volume = Math.max(0, Math.min(1, aVol));
  audioB.volume = Math.max(0, Math.min(1, bVol));
}
function crossfadeTo(target) {
  // target = 'A' or 'B'
  if(fadeInterval) { clearInterval(fadeInterval); fadeInterval = null; }
  const from = (target === 'A') ? audioB : audioA;
  const to = (target === 'A') ? audioA : audioB;
  // make sure to is ready
  try { to.play().catch(()=>{}); } catch(e){}
  const steps = Math.round(CROSSFADE_MS / 40);
  let step = 0;
  const fromStart = from.volume || 1;
  const toStart = to.volume || 0;
  const fromDelta = fromStart / steps;
  const toDelta = (1 - toStart) / steps;
  fadeInterval = setInterval(() => {
    step++;
    const newFrom = Math.max(0, fromStart - fromDelta * step);
    const newTo = Math.min(1, toStart + toDelta * step);
    if(target === 'A') setVolumes(newTo, newFrom);
    else setVolumes(newFrom, newTo);
    if(step >= steps){
      clearInterval(fadeInterval); fadeInterval = null;
      // pause the non-active to free cpu
      if(target === 'A'){ audioB.pause(); audioB.currentTime = localStorage.getItem(STORAGE.musicBTime) ? parseFloat(localStorage.getItem(STORAGE.musicBTime)) : 0; }
      else { audioA.pause(); audioA.currentTime = localStorage.getItem(STORAGE.musicATime) ? parseFloat(localStorage.getItem(STORAGE.musicATime)) : 0; }
      activeTrack = target;
      saveMusicState();
      updatePlayButtons();
    }
  }, 40);
}

/* ========= save/restore music state so reloads keep time (may be blocked on autoplay) ========= */
function saveMusicState(){
  try{
    localStorage.setItem(STORAGE.musicATime, audioA.currentTime || 0);
    localStorage.setItem(STORAGE.musicBTime, audioB.currentTime || 0);
    localStorage.setItem(STORAGE.musicPlaying, (activeTrack === 'A' ? !audioA.paused : !audioB.paused) ? 'true' : 'false');
    localStorage.setItem(STORAGE.unlocked, 'true');
  }catch(e){ console.warn('saveMusicState failed', e); }
}
function restoreMusicState(){
  try{
    const aTime = parseFloat(localStorage.getItem(STORAGE.musicATime) || '0');
    const bTime = parseFloat(localStorage.getItem(STORAGE.musicBTime) || '0');
    audioA.currentTime = aTime || 0;
    audioB.currentTime = bTime || 0;
    const playing = localStorage.getItem(STORAGE.musicPlaying) === 'true';
    // default volumes
    audioA.volume = 1; audioB.volume = 0;
    if(playing){
      // we can't guarantee autoplay will succeed without a user gesture; invocation after heart click is the reliable path.
      audioA.play().catch(()=>{});
      activeTrack = 'A';
    }
  }catch(e){ console.warn('restore fail', e); }
}

/* update play/pause button labels */
function updatePlayButtons(){
  const playing = (activeTrack === 'A') ? !audioA.paused : !audioB.paused;
  const label = playing ? '‚è∏ Pause' : '‚ñ∂ Play';
  playPause.textContent = label;
  playPause2.textContent = label;
}

/* unified play/pause toggle */
function togglePlayPause(){
  const playing = (activeTrack === 'A') ? !audioA.paused : !audioB.paused;
  if(playing){
    audioA.pause(); audioB.pause();
  } else {
    if(activeTrack === 'A'){ audioA.play().catch(()=>{}); } else { audioB.play().catch(()=>{}); }
  }
  updatePlayButtons();
  saveMusicState();
}

/* ========= UI: open/close views and song switching ========= */
function openAppFromPopup(){
  // hide overlay and show app
  overlay.classList.add('vanish');
  setTimeout(()=> overlay.style.display = 'none', 650);
  app.classList.add('active');
  // start slideshow & timer
  startSlides();
  startTimer();
  // try to restore saved position
  restoreMusicState();
  // attempt to play audioA (Sahiba). Because this is a direct user gesture, browsers should allow it.
  audioA.volume = 1; audioB.volume = 0;
  audioA.play().catch(()=>{});
  activeTrack = 'A';
  updatePlayButtons();
  // save unlocked
  localStorage.setItem(STORAGE.unlocked, 'true');
}

/* click handlers that switch views and crossfade songs */
goMessage.addEventListener('click', () => {
  // show message, crossfade audio to B
  timerView.style.display = 'none';
  messageView.classList.add('show');
  messageView.setAttribute('aria-hidden','false');
  // start audioB from stored time
  const savedB = parseFloat(localStorage.getItem(STORAGE.musicBTime) || '0');
  audioB.currentTime = savedB || 0;
  audioB.play().catch(()=>{});
  crossfadeTo('B');
});

backTimer.addEventListener('click', () => {
  // show timer, crossfade to A
  messageView.classList.remove('show');
  timerView.style.display = '';
  crossfadeTo('A');
});

/* play/pause UI */
playPause.addEventListener('click', togglePlayPause);
playPause2.addEventListener('click', togglePlayPause);

/* double-tap heart activation (mobile + desktop tolerant) */
let lastTap = 0;
function heartTapHandler(e){
  const now = Date.now();
  if(now - lastTap < 400){
    openAppFromPopup();
    lastTap = 0;
  } else lastTap = now;
}
heart.addEventListener('click', heartTapHandler);
heart.addEventListener('touchend', function(e){ heartTapHandler(e); }, {passive:false});

/* if user already unlocked earlier, auto-open (but don't auto-play music without gesture) */
if(localStorage.getItem(STORAGE.unlocked) === 'true'){
  // hide popup, show app immediately, but do NOT try to autoplay audio
  overlay.style.display = 'none';
  app.classList.add('active');
  buildSlides(imageUrls); // still build so visuals show
  startSlides();
  startTimer();
  // restore last known positions but do not force play
  const aTime = parseFloat(localStorage.getItem(STORAGE.musicATime) || '0');
  const bTime = parseFloat(localStorage.getItem(STORAGE.musicBTime) || '0');
  audioA.currentTime = aTime || 0;
  audioB.currentTime = bTime || 0;
  audioA.volume = 1; audioB.volume = 0;
  activeTrack = 'A';
  updatePlayButtons();
} else {
  // preload images, only after images loaded build DOM (avoids blank slides)
  preloadImages(imageUrls, (loaded) => {
    buildSlides(loaded);
  });
}

/* but also ensure slides are built once for the normal path (if unlocked path used above it already built) */
function buildSlides(loadedUrls){
  // if called twice guard
  if(bgContainerHasSlides()) return;
  // if no loadedUrls passed (called earlier), use imageUrls as fallback and attempt to create <img> anyway
  const use = (Array.isArray(loadedUrls) && loadedUrls.length>0) ? loadedUrls : imageUrls;
  buildSlidesDOM(use);
}
function bgContainerHasSlides(){ return bgContainer && bgContainer.children.length > 0; }
function buildSlidesDOM(urls){
  bgContainer.innerHTML = '';
  slides = [];
  urls.forEach((u,i) => {
    const el = document.createElement('img');
    el.className = 'slide';
    el.alt = 'background';
    el.src = u;
    if(i===0) el.classList.add('active');
    // if image fails to load, hide element to prevent black flash
    el.onerror = () => { el.style.display = 'none'; };
    bgContainer.appendChild(el);
    slides.push(el);
  });
}

/* startSlides only after slides exist; if buildSlides called later, startSlides will pick them up */
function startSlides(){
  if(slideTimer) clearInterval(slideTimer);
  if(!slides || slides.length === 0) return;
  slideIndex = 0;
  slides.forEach((s,i)=> s.classList.toggle('active', i===0));
  slideTimer = setInterval(() => {
    if(!slides || slides.length === 0) return;
    slides[slideIndex].classList.remove('active');
    slideIndex = (slideIndex + 1) % slides.length;
    slides[slideIndex].classList.add('active');
  }, SLIDE_INTERVAL);
}

/* ensure periodic saving of music times */
setInterval(() => {
  try{
    if(!audioA.paused) localStorage.setItem(STORAGE.musicATime, audioA.currentTime);
    if(!audioB.paused) localStorage.setItem(STORAGE.musicBTime, audioB.currentTime);
  }catch(e){}
}, 1000);

/* on page unload, save music state */
window.addEventListener('beforeunload', () => { saveMusicState(); });

/* Utility: if user taps heart (unlock) but images weren't preloaded previously, build then start */
heart.addEventListener('click', ()=> {
  if(!bgContainerHasSlides()){
    // try to build from imageUrls immediately (best-effort)
    buildSlidesDOM(imageUrls);
  }
});

</script>
</body>
</html>
